// api/services/ordersServiceFactory.mjs

/**
 * createOrdersService(db)
 * - db must expose:
 *    - async getStockServices(): Promise<Array>
 *
 * Returns:
 *  - getStockServices()
 *
 * Service throws domain errors for HTTP layer to map.
 */
export default function createStockServices(db) {
    if (!db) {
        throw "Services dependency invalid";
    }

    return {
        getStockServices,
        updateStock
    };
    /**
    * Fetches orders and applies filters, sorting, and limit in a chained style.
    *
    * @async
    * @param {Object} [options]
    * @param {number} [options.limit] - Maximum number of orders.
    * @param {string|boolean} [options.status] - Status filter.
    * @param {string} [options.q] - Query string.
    * @returns {Promise<Object[]>} Filtered, sorted, and limited orders.
    */
    async function getStockServices({ limit, q } = {}) {
        return db.getStocks()
            .then(stock => {
                return stock
            });
    }
}



  /**
  * Update an existing order by applying changes and persisting to DB.
  *
  * @async
  * @param {string|number} orderID - The id of the stock to update.
  * @param {Object} stockChange - Fields to merge into the order.
  * @returns {Promise<Object>} The updated stock as persisted in the DB.
  * @throws {ValidationError} If the stock ID is invalid.
  * @throws {NotFoundError} If the stock does not exist.
  * @throws {ExternalServiceError} If the DB operation fails.
  */
  async function updateStock(stockID, stockChanges = {}) {
    return validateAndNormalizeID(stockID)
      .then(normalizedId =>
        db.getOrderById(normalizedId).then(existingOrder => {
          const updated = mergeOrderChanges(existingOrder, stockChanges);
          updated.updatedAt = new Date().toISOString();
          return db.updateOrderDB(normalizedId, updated);
        })
      );
  }



